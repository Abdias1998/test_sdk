"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  APIError: () => APIError,
  Feexpay: () => Feexpay,
  FeexpayError: () => FeexpayError,
  NetworkError: () => NetworkError,
  ValidationError: () => ValidationError
});
module.exports = __toCommonJS(index_exports);

// src/core.ts
var import_axios = __toESM(require("axios"));

// src/types.ts
var FeexpayError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
    this.name = "FeexpayError";
  }
};
var NetworkError = class extends FeexpayError {
  constructor(message) {
    super(message, "NETWORK_ERROR");
    this.name = "NetworkError";
  }
};
var APIError = class extends FeexpayError {
  constructor(message, status) {
    super(message, "API_ERROR");
    this.status = status;
    this.name = "APIError";
  }
};
var ValidationError = class extends FeexpayError {
  constructor(message) {
    super(message, "VALIDATION_ERROR");
    this.name = "ValidationError";
  }
};

// src/core.ts
var Core = class {
  constructor(token, id, options = {}) {
    this.token = token;
    this.id = id;
    this.options = {
      mode: options.mode || "LIVE",
      timeout: options.timeout || 3e4,
      maxRetries: options.maxRetries || 3
    };
    const baseURL = this.options.mode === "LIVE" ? "https://api.feexpay.me" : "https://api.feexpay.me";
    this.client = import_axios.default.create({
      baseURL,
      timeout: this.options.timeout,
      headers: {
        "Authorization": `Bearer ${this.token}`,
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    });
  }
  /**
   * Makes an HTTP request with retry logic
   * @private
   */
  async _makeRequest(method, endpoint, data, retryCount = 0) {
    try {
      const response = await this.client.request({
        method,
        url: endpoint,
        data
      });
      return response.data;
    } catch (error) {
      if (error instanceof import_axios.AxiosError) {
        if (!error.response) {
          if (retryCount < this.options.maxRetries) {
            const delay = Math.pow(2, retryCount) * 1e3;
            await new Promise((resolve) => setTimeout(resolve, delay));
            return this._makeRequest(method, endpoint, data, retryCount + 1);
          }
          throw new NetworkError("Network request failed");
        }
        const status = error.response.status;
        const message = error.response.data?.message || error.message;
        if (status === 400) {
          throw new ValidationError(message);
        }
        throw new APIError(message, status);
      }
      throw error;
    }
  }
  // protected async _makeRequest<T>(
  //   method: string,
  //   endpoint: string,
  //   data?: any
  // ): Promise<T> {
  //   console.log('Making request to:', endpoint);
  //   console.log('Request payload:', JSON.stringify(data, null, 2));
  //   try {
  //     const response = await this.client.request<T>({ method, url: endpoint, data });
  //     return response.data;
  //   } catch (error) {
  //     if (error instanceof AxiosError && error.response) {
  //       console.error('API Error details:', error.response.data);
  //     }
  //     throw error;
  //   }
  // }
};

// src/payment.ts
var PaymentService = class extends Core {
  /**
   * Create a new payment
   * @param params Payment creation parameters
   * @returns Payment creation response
   * @example
   * ```typescript
   * const payment = await feexpay.payment.create({
   *   amount: 5000,
   *   currency: 'XOF',
   *   customer: {
   *     email: 'customer@example.com',
   *     name: 'John Doe'
   *   },
   *   callback_url: 'https://example.com/callback'
   * });
   * ```
   */
  async create(params) {
    return this._makeRequest("POST", `/api/transactions/public/requesttopay/${params.network}`, params);
  }
  /**
   * Verify payment status
   * @param transactionId Payment transaction ID
   * @returns Payment verification response
   * @example
   * ```typescript
   * const status = await feexpay.payment.verify('tx_123456');
   * ```
   */
  async verify(transactionId) {
    return this._makeRequest(
      "GET",
      `/api/transactions/getrequesttopay/integration/${transactionId}`
    );
  }
};

// src/webhooks.ts
var import_crypto = __toESM(require("crypto"));
var WebhooksService = class {
  /**
   * Verify webhook signature
   * @param payload Raw webhook payload
   * @param signature Signature from X-Feexpay-Signature header
   * @param secret Webhook secret key
   * @returns boolean
   * @example
   * ```typescript
   * const isValid = feexpay.webhooks.verifySignature(
   *   payload,
   *   signature,
   *   'whsec_...'
   * );
   * ```
   */
  verifySignature(payload, signature, secret) {
    const expectedSignature = import_crypto.default.createHmac("sha256", secret).update(payload).digest("hex");
    return import_crypto.default.timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    );
  }
  /**
   * Parse webhook event
   * @param payload Webhook payload
   * @returns Parsed event object
   * @example
   * ```typescript
   * const event = feexpay.webhooks.parseEvent(payload);
   * ```
   */
  parseEvent(payload) {
    try {
      return JSON.parse(payload);
    } catch (error) {
      throw new ValidationError("Invalid webhook payload");
    }
  }
};

// src/transaction.ts
var import_axios2 = __toESM(require("axios"));
var Transaction = class {
  static configure(token, id, options) {
    this.token = token;
    this.id = id;
    this.options = options;
  }
  static async create(data) {
    if (!this.token || !this.id) {
      throw new Error("Transaction class is not configured. Call Transaction.configure() first.");
    }
    if (!data.network) {
      throw new Error("Network is required for transaction creation.");
    }
    const url = this.options?.mode === "LIVE" ? `https://api.feexpay.me/api/transactions/public/requesttopay/${data.network}` : `https://sandbox.feexpay.me/api/transactions/public/requesttopay/${data.network}`;
    const headers = {
      Authorization: `Bearer ${this.token}`,
      "Content-Type": "application/json"
    };
    const payload = {
      ...data,
      shop: this.id
    };
    const response = await import_axios2.default.post(url, payload, { headers });
    return response.data;
  }
  static async verify(reference) {
    if (!this.token) {
      throw new Error("Transaction class is not configured.");
    }
    const url = this.options?.mode === "LIVE" ? `https://api.feexpay.me/api/transactions/getrequesttopay/integration/${reference}` : `https://sandbox.feexpay.me/api/transactions/getrequesttopay/integration/${reference}`;
    const headers = {
      Authorization: `Bearer ${this.token}`
    };
    const response = await import_axios2.default.get(url, { headers });
    return response.data;
  }
};

// src/index.ts
var Feexpay = class {
  constructor(token, id, options) {
    this.payment = new PaymentService(token, id, options);
    this.webhooks = new WebhooksService();
    Transaction.configure(token, id, options);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  APIError,
  Feexpay,
  FeexpayError,
  NetworkError,
  ValidationError
});
